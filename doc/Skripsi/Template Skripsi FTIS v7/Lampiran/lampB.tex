\chapter{The Source Code}
\label{app:B}

%selalu gunakan single spacing untuk source code !!!!!
\singlespacing 
% language: bahasa dari kode program
% terdapat beberapa pilihan : Java, C, C++, PHP, Matlab, R, dll
%
% basicstyle : ukuran font untuk kode program
% terdapat beberapa pilihan : tiny, scriptsize, footnotesize, dll
%
% caption : nama yang akan ditampilkan di dokumen akhir, lihat contoh
\begin{lstlisting}[language=Java,basicstyle=\tiny,caption=Controller.java]
package DataMiningLogHistoriKIRIWithoutDateAndMinutes;

import java.awt.image.BufferedImage;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import weka.core.Instances;

/**
 *
 * @author Jovan Gunawan
 */
public class Controller
{
    public Controller()
    {
    }
    
    public void startMining(String inputFilePath, String miningAlgo, JLabel label, JTextArea textArea) throws IOException
    {
        CSVReader csv = new CSVReader();
        ArrayList<String[]> data = csv.readCSV(inputFilePath);
        
        ArrayList<String[]> findRoute = new ArrayList<String[]>();
        ProcessingData pd = new ProcessingData();
        pd.processSorting(findRoute, data, "FINDROUTE");
        
        //int maxMin digunakan untuk menyimpan nilai max dan min dari variable bulan dan tahun. Untuk ketentuan posisi array dapat dilihat di method preprocessing data
        int[] maxMin = new int[4];
        ArrayList<int[]> dataAfterPreprocessing = pd.preprocessingData(findRoute, maxMin);
        
        ArffIO io = new ArffIO();
        io.writeArrf("tempArff", dataAfterPreprocessing);
        
        Instances arff = io.readArff("temp.arff");
        //arff.setClassIndex(arff.numAttributes() - 1);
        DecisionTree dt = new DecisionTree();
        String [] tempTreeDataResult;
        System.out.println(miningAlgo);
        if(miningAlgo.equals("id3"))
        {
             textArea.setText(dt.id3(arff));
        }
        else
        {
             textArea.setText(dt.j48(arff));
        }
        tempTreeDataResult = textArea.getText().split("\n");
        textArea.setText(textArea.getText() + "\nNilai Confident: " + dt.calculatePrecision(arff) + "\n");
        String[] treeDataResult;
        System.out.println(tempTreeDataResult.length);
        if(tempTreeDataResult.length < 8)
        {
            if(miningAlgo.equals("id3"))
            {
                treeDataResult = new String[tempTreeDataResult.length-2];
            }
            else
            {
                treeDataResult = new String[tempTreeDataResult.length-6];
            }
            System.arraycopy(tempTreeDataResult, 2, treeDataResult, 0, treeDataResult.length);
        }
        else
        {
            if(miningAlgo.equals("id3"))
            {
                treeDataResult = new String[tempTreeDataResult.length-3];
            }
            else
            {
                treeDataResult = new String[tempTreeDataResult.length-7];
            }
            System.arraycopy(tempTreeDataResult, 3, treeDataResult, 0, treeDataResult.length);
        }
        System.out.println(treeDataResult[0]);
        SDForConvertTree dataTree = new SDForConvertTree(treeDataResult);
        
        try {
            PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("tree.txt")));
            SDForExtractData extract = new SDForExtractData(new String[]{"bulan", "tahun", "hari", "jam"},new int[]{maxMin[0],maxMin[1],7,24}, new int[]{maxMin[2],maxMin[3],1,0});
            out.println("digraph{" + DotConverter.convert(dataTree, extract, miningAlgo, 0, "") + "}");
            out.close();
            
            textArea.setText(textArea.getText());
            ArrayList<String> extractData = extract.getList();
            
            if(extractData.size() > 0)
            {
                textArea.setText(textArea.getText() + "\nExtract Data\n");
            }
            for(int i = 0; i < extractData.size(); i++)
            {
                textArea.setText(textArea.getText() + "\n" + extractData.get(i));
            }
            
        } catch (IOException ex) {
            System.out.println("Error ketika menulis file txt");
        }
        
        Cmd.makeJpgUsingDotCommand();
        
        JFrame jf2 = new JFrame();
        
        jf2.setVisible(true);
        jf2.setSize(620, 500);
        BufferedImage image = null;
        image = ImageIO.read(new File("tree.jpg"));
        ImageIcon image2 = new ImageIcon(image);
        JLabel labels = new JLabel(image2);
        JScrollPane pane = new JScrollPane(labels);
        jf2.setContentPane(pane);
    }
    
    
    public static void main (String [] args) 
    {
        Controller cont = new Controller();
        
        JFrame jf = new JFrame();
        View v = new View(cont);
        
        jf.setVisible(true);
        jf.setSize(620, 500);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        jf.add(v);
    }
}

\end{lstlisting}

\begin{lstlisting}[language=Java,basicstyle=\tiny,caption=View.java]
package DataMiningLogHistoriKIRIWithoutDateAndMinutes;

import java.io.File;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;

/**
 *
 * @author Jovan Gunawan
 */
public class View extends javax.swing.JPanel {

    /**
     * Creates new form View
     */
    public View(Controller cont) {
        this.cont = cont;
        initComponents();
        buttonGroup1.add(radioButtonId3);
        buttonGroup1.add(radioButtonC45);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        judul = new javax.swing.JLabel();
        labelFileData = new javax.swing.JLabel();
        labelPemilihanMethod = new javax.swing.JLabel();
        radioButtonId3 = new javax.swing.JRadioButton();
        radioButtonC45 = new javax.swing.JRadioButton();
        textFieldFilePath = new javax.swing.JTextField();
        buttonStart = new javax.swing.JButton();
        scrollPanel = new javax.swing.JScrollPane();
        hasil = new javax.swing.JTextArea();
        labelHasil = new javax.swing.JLabel();
        buttonBrowse = new javax.swing.JButton();
        labelKeterangan = new javax.swing.JLabel();

        judul.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        judul.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        judul.setText("Data Mining Log Histori KIRI");

        labelFileData.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        labelFileData.setText("File Data (CSV):");

        labelPemilihanMethod.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        labelPemilihanMethod.setText("Metode Pembuatan Tree:");

        radioButtonId3.setSelected(true);
        radioButtonId3.setText("ID3");

        radioButtonC45.setText("C45");
        radioButtonC45.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                radioButtonC45ActionPerformed(evt);
            }
        });

        buttonStart.setText("Start!");
        buttonStart.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonStartActionPerformed(evt);
            }
        });

        hasil.setColumns(20);
        hasil.setRows(5);
        scrollPanel.setViewportView(hasil);

        labelHasil.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        labelHasil.setText("Hasil:");

        buttonBrowse.setText("Browse");
        buttonBrowse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonBrowseActionPerformed(evt);
            }
        });

        labelKeterangan.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addGap(117, 117, 117)
                        .addComponent(judul, javax.swing.GroupLayout.PREFERRED_SIZE, 399, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addGap(85, 85, 85)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(labelFileData, javax.swing.GroupLayout.DEFAULT_SIZE, 138, Short.MAX_VALUE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(textFieldFilePath, javax.swing.GroupLayout.PREFERRED_SIZE, 209, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, 18)
                                .addComponent(buttonBrowse))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(labelPemilihanMethod, javax.swing.GroupLayout.PREFERRED_SIZE, 147, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(radioButtonId3)
                                        .addGap(18, 18, 18)
                                        .addComponent(radioButtonC45))
                                    .addComponent(buttonStart, javax.swing.GroupLayout.PREFERRED_SIZE, 124, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(labelHasil, javax.swing.GroupLayout.PREFERRED_SIZE, 89, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(scrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 441, Short.MAX_VALUE)
                                    .addComponent(labelKeterangan, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addGap(0, 0, Short.MAX_VALUE)))))
                .addGap(84, 84, 84))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(judul, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(labelFileData, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(textFieldFilePath, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(buttonBrowse))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(labelPemilihanMethod, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(radioButtonC45)
                    .addComponent(radioButtonId3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(buttonStart)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(labelHasil, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(2, 2, 2)
                .addComponent(scrollPanel, javax.swing.GroupLayout.PREFERRED_SIZE, 251, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 10, Short.MAX_VALUE)
                .addComponent(labelKeterangan, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
    }// </editor-fold>                        

    private void buttonBrowseActionPerformed(java.awt.event.ActionEvent evt) {                                             
        final JFileChooser fc = new JFileChooser();
        int returnVal = fc.showOpenDialog(buttonStart);

        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = fc.getSelectedFile();
            textFieldFilePath.setText(file.getPath());
        } else {
            System.out.println("Error in capture the path");
            System.exit(1);
        }
    }                                            

    private void buttonStartActionPerformed(java.awt.event.ActionEvent evt) {                                            
        String inputPath = textFieldFilePath.getText();
        String miningAlgo = "";
        if(radioButtonId3.isSelected())
        {
            miningAlgo = "id3";
        }
        else
        {
            miningAlgo = "c45";
        }
        
        try {
            cont.startMining(inputPath, miningAlgo, labelKeterangan, hasil);
        }catch(IOException e)
        {
            System.out.println("Error start mining");
            System.exit(1);
        }
    }                                           

    private void radioButtonC45ActionPerformed(java.awt.event.ActionEvent evt) {                                               
        // TODO add your handling code here:
    }                                              


    // Variables declaration - do not modify                     
    private javax.swing.JButton buttonBrowse;
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JButton buttonStart;
    private javax.swing.JTextArea hasil;
    private javax.swing.JLabel judul;
    private javax.swing.JLabel labelFileData;
    private javax.swing.JLabel labelHasil;
    private javax.swing.JLabel labelKeterangan;
    private javax.swing.JLabel labelPemilihanMethod;
    private javax.swing.JRadioButton radioButtonId3;
    private javax.swing.JRadioButton radioButtonC45;
    private javax.swing.JScrollPane scrollPanel;
    private javax.swing.JTextField textFieldFilePath;
    // End of variables declaration                   
    private Controller cont;
}

\end{lstlisting}

\begin{lstlisting}[language=Java,basicstyle=\tiny,caption=CSVReader.java]
package DataMiningLogHistoriKIRIWithoutDateAndMinutes;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Set;

/**
 *
 * @author Jovan Gunawan
 */
public class CSVReader
{
    private ArrayList<String[]> data;
    private int banyakAtribut;
    public CSVReader() 
    {
        data = new ArrayList<String[]>();
        banyakAtribut = 0;
    }

    public void setEmpty()
    {
        getData().clear();
    }
    public ArrayList readCSV(String [] file)
    {
        for(int i = 0; i < file.length; i++)
        {
            readCSV(file[i]);
        }
        return getData();
    }
    public ArrayList readCSV(String file)
    {
        try
        {
            String temp;
            String [] splited;
            int i=0;
            BufferedReader br = new BufferedReader(new FileReader(file));
            while ((temp = br.readLine()) != null)
            {
                splited = temp.split("\"");
                if(i==0)
                {
                    //baca atributnya terlebih dahulu
                    ArrayList al = new ArrayList<String>();
                    String tempAtribut ="";
                    for(int j = 0; j < splited.length; j++)
                    {
                        if(j%2 == 0)
                        {
                            String [] splitedKoma = splited[j].split(",");
                            for(int k = 0; k < splitedKoma.length; k++)
                            {
                                if(!(k == 0 && splitedKoma[k].length() ==0)||(k==splitedKoma.length-1 && splitedKoma[k].length() == 0))
                                {
                                    al.add(splitedKoma[k]);
                                }
                            }
                        }
                        else
                        {
                            al.add(splited[j]);
                        }
                    }
                    banyakAtribut = al.size();
                    String[] tempDataAtribut = new String[banyakAtribut];
                    for(int j = 0; j < banyakAtribut; j++)
                    {
                        tempDataAtribut[j] = (String)al.get(j);
                    }
                    getData().add(tempDataAtribut);
                    i++;
                }
                else
                {
                    //baca untuk datanya
                    int index = 0;
                    String [] tempData = new String[banyakAtribut];
                    for(int j = 0; j < splited.length; j++)
                    {
                        if(j%2 == 0)
                        {
                            String [] splitedKoma = splited[j].split(",");
                            for(int k = 0; k < splitedKoma.length; k++)
                            {
                                if(!(k == 0 && splitedKoma[k].length() ==0)||(k==splitedKoma.length-1 && splitedKoma[k].length() == 0))
                                {
                                    tempData[index] = splitedKoma[k];
                                    index++;
                                }
                            }
                        }
                        else
                        {
                            tempData[index] = splited[j];
                            index++;
                        }
                    }
                    getData().add(tempData);
                    i++;
                }
            }
            for(int j = 0; j < i; j++)
            {
                String [] temp2 = (String[])getData().get(j);
            }
            br.close();
        }catch(IOException e)
        {
            System.out.println("Failed to read data");
        }
        return getData();
    }

    public ArrayList getData()
    {
        return data;
    }
    public void setData(ArrayList data)
    {
        this.data = data;
    }
    public int getBanyakAtribut()
    {
        return banyakAtribut;
    }
    public void setBanyakAtribut(int banyakAtribut)
    {
        this.banyakAtribut = banyakAtribut;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=Java,basicstyle=\tiny,caption=ProcessingData.java]
package DataMiningLogHistoriKIRIWithoutDateAndMinutes;

import java.util.ArrayList;

/**
 *
 * @author Jovan Gunawan
 */
public class ProcessingData
{
    ProcessingData()
    {
    }

    public void processSorting(ArrayList addApiKey, ArrayList findRoute, ArrayList login, ArrayList nearbyTransport, ArrayList pageLoad, ArrayList register, ArrayList searchPlace, ArrayList widgetError, ArrayList widgetLoad, ArrayList data)
    {
        System.out.println("Banyak Data: " + data.size());
        for(int i =0; i < data.size(); i++)
        {
            String [] tempData = (String[])data.get(i);
            if(tempData[3].equals("ADDAPIKEY"))
            {
                addApiKey.add(tempData);
            }
            else if(tempData[3].equals("FINDROUTE"))
            {
                findRoute.add(tempData);
            }
            else if(tempData[3].equals("LOGIN"))
            {
                login.add(tempData);
            }
            else if(tempData[3].equals("NEARBYTRANSPORT"))
            {
                nearbyTransport.add(tempData);
            }
            else if(tempData[3].equals("PAGELOAD"))
            {
                pageLoad.add(tempData);
            }
            else if(tempData[3].equals("REGISTER"))
            {
                register.add(tempData);
            }
            else if(tempData[3].equals("SEARCHPLACE"))
            {
                searchPlace.add(tempData);
            }
            else if(tempData[3].equals("WIDGETERROR"))
            {
                widgetError.add(tempData);
            }
            else if(tempData[3].equals("WIDGETLOAD"))
            {
                widgetLoad.add(tempData);
            }
        }
    }
    public void processSorting(ArrayList array, ArrayList data, String action)
    {
        for(int i =0; i < data.size(); i++)
        {
            String [] tempData = (String[])data.get(i);
            if(tempData[3].equals(action))
            {
                array.add(tempData);
            }
        }
    }
    public ArrayList preprocessingData(ArrayList<String[]> data, int[] maxMin)
    {
        // 2 int[] untuk mendapatkan nilai max dan min dari varible bulan dan tahun yang digunakan untuk inisialisasi max min pada kelas SDForExtractData.
        // array pertama untuk bulan, dan array kedua untuk tahun
        int []max = new int[2];
        int []min = new int[2];
        max[0] = 0;
        max[1] = 0;
        min[0] = Integer.MAX_VALUE;
        min[1] = Integer.MAX_VALUE;
        
        ArrayList<int[]> result = new ArrayList<int[]>();
        
        // tahap pertama: ubah waktu dari UTC ke GMT+7
        for(int i = 0; i < data.size(); i++)
        {
            data.get(i)[2] = TimezoneConverter.convertToGMT7(data.get(i)[2]);
        }
        
        // tahap kedua sampai kesembilan
        DistanceHaversine haversine = new DistanceHaversine();
        for(int i = 0; i < data.size(); i++)
        {
            //cek apakah format sudah benar atau belum
            if(data.get(i)[4].split(",").length == 3)
            {
                // tahap kedua: pecah string atribut tanggal
                int[] temp = new int[5];
                String[] splited = data.get(i)[2].split(" ");
                temp[2] = Integer.parseInt(splited[0]);
                // tahap ketiga: pecah nilai string yang tanggal
                String[] splited2 = splited[1].split("/");
                temp[0] = Integer.parseInt(splited2[0]);
                temp[1] = Integer.parseInt(splited2[2]);
                // tahap keempat: pecah nilai string yang jam
                splited2 = splited[2].split(":");
                temp[3] = Integer.parseInt(splited2[0]);
                // tahap kelima: pecah string atribut additional data
                splited = data.get(i)[4].split("/");
                // tahap keenam: pecah lokasi keberangkatan dan lokasi tujuan untuk mendapatkan lat n lon dan (ini tahap ketujuh) menghitung jarak terhadap titik pusat
                splited2 = splited[0].split(",");
                double jarakKeberangkatan = haversine.calculateDistance(Double.parseDouble(splited2[0]), Double.parseDouble(splited2[1]), -6.916667,107.6) * 1000;
                splited2 = splited[1].split(",");
                double jarakTujuan = haversine.calculateDistance(Double.parseDouble(splited2[0]), Double.parseDouble(splited2[1]), -6.916667,107.6) * 1000;
                // tahap kedelapan, set semua data ke array
                temp[4] = klasifikasiKelas(jarakKeberangkatan, jarakTujuan);

                if(temp[4] != -2)
                {
                    result.add(temp);
                    //proses untuk mencatat nilai max dan min
                    if(max[0] < temp[0])
                    {
                        max[0] = temp[0];
                    }
                    if(min[0] > temp[0])
                    {
                        min[0] = temp[0];
                    }
                    if(max[1] < temp[1])
                    {
                        max[1] = temp[1];
                    }
                    if(min[1] > temp[1])
                    {
                        min[1] = temp[1];
                    }
                }
            }
            else
            {
                System.out.println("ERROR: additional data tidak sesuai; " + data.get(i)[4]);
            }
        }
        maxMin[0] = max[0];
        maxMin[1] = max[1];
        maxMin[2] = min[0];
        maxMin[3] = min[1];
        return result;
    }
    
    public int klasifikasiKelas(double jarakKeberangkatan, double jarakTujuan)
    {
        int regionKeberangkatan, regionTujuan;
        int klasifikasi = 0; // -1 --> tidak menuju Bandung, 0 --> menuju Bandung, 1 --> menuju region yang sama
        
        regionKeberangkatan = (int)jarakKeberangkatan;
        regionTujuan = (int)jarakTujuan;
        
        if(regionKeberangkatan >= 11 && regionTujuan >= 11)
        {
            return -2;
        }
        else
        {
            if (regionKeberangkatan > regionTujuan)
            {
                klasifikasi = -1;
            }
            else if (regionKeberangkatan < regionTujuan)
            {
                klasifikasi = 1;
            }
            else
            {
                klasifikasi = 0;
            }
            return klasifikasi;
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[language=Java,basicstyle=\tiny,caption=TimezoneConverter.java]
package DataMiningLogHistoriKIRIWithoutDateAndMinutes;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author Jovan Gunawan
 */
public class TimezoneConverter 
{
    // Mengubah input waktu menjadi waktu GMT+7
    // Jika ingin mengubah dari UTC ke GMT+7 maka komputer harus set timezone ke UTC
    // input parameter string harus dalam format dd-MM-yyyy HH:mm:ss --> contoh 1/1/2014  3:51:15 AM
    // output akan mengubah waktu menjadi GMT+7 dalam String dengan format EEE MM/dd/yyyy HH:mm:ss --> contoh Wed 01/01/2014 03:51:15
    public static String convertToGMT7(String date)
    {
        Date d = null;
        long milliseconds = 0;
        
        try {
            SimpleDateFormat f = new SimpleDateFormat("MM/dd/yyyy HH:mm");
            d = (Date)f.parse(date);
        } catch (ParseException ex) {
            SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            try {
                d = (Date)f.parse(date);
            } catch (ParseException ex1) {
                Logger.getLogger(TimezoneConverter.class.getName()).log(Level.SEVERE, null, ex);
                System.exit(1);
            }
        }
        milliseconds = d.getTime();
        
        Date currentTime = new Date(milliseconds);
        // untuk hari --> 1 = senin,..., 7 = minggu
        SimpleDateFormat sdf = new SimpleDateFormat("u MM/dd/yyyy HH:mm:ss");
        
        sdf.setTimeZone(TimeZone.getTimeZone("GMT+7"));
        return sdf.format(currentTime);
    }
}
\end{lstlisting}

\begin{lstlisting}[language=Java,basicstyle=\tiny,caption=DistanceHaversine.java]
package DataMiningLogHistoriKIRIWithoutDateAndMinutes;

/**
 *
 * @author Jovan Gunawan
 */
public class DistanceHaversine
{
    private double r;
    public DistanceHaversine()
    {
         r = 6.371;
    }

    public double calculateDistance(double latitude1, double longitude1, double latitude2, double longitude2)
    {
        latitude1 = Math.toRadians(latitude1);
        longitude1 = Math.toRadians(longitude1);
        latitude2 = Math.toRadians(latitude2);
        longitude2 = Math.toRadians(longitude2);

        double dlon = longitude2 - longitude1;
        double dlat = latitude2 - latitude1;

        double a = Math.pow((Math.sin(dlat/2)),2) + Math.cos(latitude1) * Math.cos(latitude2) * Math.pow(Math.sin(dlon/2),2);

        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return r * c;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=Java,basicstyle=\tiny,caption=ArffIO.java]
package DataMiningLogHistoriKIRIWithoutDateAndMinutes;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import weka.core.Instances;

/**
 *
 * @author Jovan Gunawan
 */
public class ArffIO 
{
    public ArffIO()
    {
    }
    
    // method writer ini dibuat KHUSUS untuk skripsi data log KIRI
    // input berupa arraylist dengan objek int[]
    // Setiap array int, terdapat 7 nilai yaitu tanggal, bulan, tahun, hari, jam, menit, menujuBandung
    // disini nilai hari akan diubah menjadi string, 1 akan menjadi senin, ..., dan 7 akan menjadi minggu
    public void writeArrf(String name, ArrayList<int[]> data)
    {
        String result = "@relation " + name + "\n\n@attribute bulan REAL\n@attribute tahun REAL\n"
                + "@attribute hari REAL"
                + "\n@attribute jam REAL\n@attribute menujuBandung {-1,0,1}\n\n@data";
        
        for(int i = 0; i < data.size(); i++)
        {
            int[] temp = data.get(i);
            result += "\n" + temp[0] + "," + temp[1] + "," + temp[2] + "," + temp[3] + "," + temp[4]; 
        }
        
        try {
            PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("temp.arff")));
            out.println(result);
            out.close();
        } catch (IOException ex) {
            System.out.println("Error ketika menulis file arff");
        }
    }
    
    public Instances readArff(String name) throws IOException
    {
        Instances data;
        data = new Instances(new BufferedReader(new FileReader("temp.arff")));
        data.setClassIndex(data.numAttributes() - 1);
        return data;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=Java,basicstyle=\tiny,caption=DecisionTree.java]
package DataMiningLogHistoriKIRIWithoutDateAndMinutes;

import java.util.logging.Level;
import java.util.logging.Logger;
import weka.classifiers.Classifier;
import weka.classifiers.trees.Id3;
import weka.classifiers.trees.J48;
import weka.core.Instances;
import weka.filters.Filter;
import weka.filters.unsupervised.attribute.NumericToNominal;

/**
 *
 * @author Jovan Gunawan
 */
public class DecisionTree 
{
    private Classifier tree;
    
    public double calculatePrecision(Instances arff)
    {
        int nilaiBenar = 0, resultInt;
        float result = 0;
        for (int i = 0; i < arff.numInstances(); i++)
        {    
            try {
                result = (float)tree.classifyInstance(arff.instance(i));
                resultInt = Math.round(result)-1;
                if(resultInt == Integer.parseInt(arff.instance(i).stringValue(4)))
                {
                    nilaiBenar++;
                }
            } catch (Exception ex) {
            }
        }
        double confident = Math.round(nilaiBenar * 1.0 / arff.numInstances() * 10000)/100.0;
        return confident;
    }
    
    public String id3(Instances arff)
    {
        tree = new Id3();
        try {
            NumericToNominal convert= new NumericToNominal();
            String[] options= new String[2];
            options[0]="-R";
            options[1]="1-4"; 

            convert.setOptions(options);
            convert.setInputFormat(arff);

            Instances newData=Filter.useFilter(arff, convert);
            
            tree.buildClassifier(newData);
        } catch (Exception ex) {
            Logger.getLogger(Controller.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        return tree.toString();
    }
    
    public String j48(Instances arff)
    {
        tree = new J48();
        try {
            tree.buildClassifier(arff);
        } catch (Exception ex) {
            Logger.getLogger(Controller.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        return tree.toString();
    }
}
\end{lstlisting}

\begin{lstlisting}[language=Java,basicstyle=\tiny,caption=DotConverter.java]
package DataMiningLogHistoriKIRIWithoutDateAndMinutes;

import DataMiningLogHistoriKIRI.*;

/**
 *
 * @author Jovan Gunawan
 */
public class DotConverter 
{
    // converter dot khusus untuk skripsi data mining log histori KIRI --> output berupa tree dalam string dari weka
    public static String convert(SDForConvertTree data, SDForExtractData extract, String miningAlgo, int deep, String nodeName)
    {
        String result = "";
        String [] temp;
        String nodeName1="", nodeName2="";
        //color 1  selalu 1.0 karena merah
        double color; 
        if(deep == 0 && data.getData().length == 1 && data.getData()[0].charAt(0) == ':')
        {
            result = data.getData()[0].split(" ")[1];
        }
        else
        {
            if(miningAlgo.equals("id3"))
            {
                boolean hasNext = true;
                int loop = 0;
                while(hasNext)
                {
                    hasNext = false;

                    temp = data.getData(0).split("  ");
                    boolean iniName1 = false;

                    System.out.println("Deep: " + deep + data.getData(0));
                    temp = temp[deep].split(" ");

                    color = 0.7 - deep * 0.02;
                    if(color < 0.3)
                    {
                        color = 0.3;
                    }

                    if(nodeName.equals(""))
                    {
                        if(loop == 0)
                        {
                            nodeName1 = data.getDataNumber(temp[0]);
                        }
                        result += nodeName1 + " -> ";
                        iniName1 = true;
                    }
                    else
                    {
                        result += nodeName + " -> ";
                    }

                    SDForExtractData tempExtract = new SDForExtractData(extract);

                    if(temp[2].charAt(temp[2].length()-1) == ':')
                    {
                        // masukin data buat extract
                        tempExtract.setRules(temp[0], temp[1], Integer.parseInt(temp[2].substring(0, temp[2].length()-1)));
                        try
                        {
                            tempExtract.setKelas(Integer.parseInt(temp[3]));
                        }catch(Exception a)
                        {
                            if(temp[3] == null)
                            {
                                tempExtract.setKelas(-2);
                            }
                        }
                        tempExtract.extract();
                        extract.addStringResult(tempExtract.getList());
                        // menghasilkan daun

                        nodeName2 = data.getDataNumber(temp[3]);
                        result += nodeName2 + " [label=\"" + temp[1] + " " + temp[2].substring(0, temp[2].length()-1) +  "\"]\n";
                        if(iniName1 && loop == 0)
                        {
                            result += nodeName1 + " [label=\"" + temp[0] + "\",shape=box,style=filled,color=\"1.0 " + color + " 1.0\"]\n";
                        }
                        result += nodeName2 + " [label=\"" + temp[3] + "\"]\n";
                        data.buangArrayPertama();
                    }
                    else
                    {
                        // masukin data bwt extract
                        tempExtract.setRules(temp[0], temp[1], Integer.parseInt(temp[2]));

                        // menghasilkan node
                        String [] temp2;
                        temp2 = data.getData(1).split("  ");
                        temp2 = temp2[deep+1].split(" ");
                        nodeName2 = data.getDataNumber(temp2[0]);
                        result += nodeName2 + " [label=\"" + temp[1] + " " + temp[2] +  "\",shape=box,style=filled,color=\"1.0 " + color + " 1.0\"]\n";
                        data.buangArrayPertama();

                        SDForExtractData newExtract = new SDForExtractData(tempExtract);
                        result += DotConverter.convert(data, newExtract, miningAlgo, deep+1, nodeName2);

                        if(iniName1 && loop == 0)
                        {
                            result += nodeName1 + " [label=\"" + temp[0] + "\",shape=box,style=filled,color=\"1.0 " + color + " 1.0\"]\n";
                        }
                        result += nodeName2 + " [label=\"" + temp2[0] + "\",shape=box,style=filled,color=\"1.0 " + color + " 1.0\"]\n";
                        extract.addStringResult(newExtract.getList());
                    }
                    if(data.hasNext())
                    {
                        if(data.getData(0).split("  ").length-1 == deep)
                        {
                            hasNext = true;
                        }
                    }
                    loop++;
                }
            }
            else
            {
                for(int i = 0; i < 2; i++)
                {
                    temp = data.getData(0).split("   ");
                    boolean iniName1 = false;

                    System.out.println("Deep: " + deep + data.getData(0));
                    temp = temp[deep].split(" ");

                    color = 0.7 - deep * 0.02;
                    if(color < 0.3)
                    {
                        color = 0.3;
                    }

                    if(nodeName.equals(""))
                    {
                        if(i == 0)
                        {
                            nodeName1 = data.getDataNumber(temp[0]);
                        }
                        result += nodeName1 + " -> ";
                        iniName1 = true;
                    }
                    else
                    {
                        result += nodeName + " -> ";
                    }

                    SDForExtractData tempExtract = new SDForExtractData(extract);

                    if(temp[2].charAt(temp[2].length()-1) == ':')
                    {   
                        // masukin data bwt extract
                        tempExtract.setRules(temp[0], temp[1], Integer.parseInt(temp[2].substring(0, temp[2].length()-1)));
                        tempExtract.setKelas(Integer.parseInt(temp[3]));
                        tempExtract.extract();
                        extract.addStringResult(tempExtract.getList());
                        // menghasilkan daun
                        nodeName2 = data.getDataNumber(temp[3]);
                        result += nodeName2 + " [label=\"" + temp[1] + " " + temp[2].substring(0, temp[2].length()-1) +  "\"]\n";
                        if(iniName1 && i == 0)
                        {
                            result += nodeName1 + " [label=\"" + temp[0] + "\",shape=box,style=filled,color=\"1.0 " + color + " 1.0\"]\n";
                        }
                        result += nodeName2 + " [label=\"" + temp[3] + "\"]\n";
                        data.buangArrayPertama();
                    }
                    else 
                    {
                        // masukin data bwt extract
                        tempExtract.setRules(temp[0], temp[1], Integer.parseInt(temp[2]));
                        // menghasilkan node
                        String [] temp2;
                        temp2 = data.getData(1).split("   ");
                        temp2 = temp2[deep+1].split(" ");
                        nodeName2 = data.getDataNumber(temp2[0]);
                        result += nodeName2 + " [label=\"" + temp[1] + " " + temp[2] +  "\",shape=box,style=filled,color=\"1.0 " + color + " 1.0\"]\n";
                        data.buangArrayPertama();

                        SDForExtractData newExtract = new SDForExtractData(tempExtract);
                        result += DotConverter.convert(data, newExtract, miningAlgo, deep+1, nodeName2);

                        if(iniName1 && i == 0)
                        {
                            result += nodeName1 + " [label=\"" + temp[0] + "\",shape=box,style=filled,color=\"1.0 " + color + " 1.0\"]\n";
                        }
                        result += nodeName2 + " [label=\"" + temp2[0] + "\",shape=box,style=filled,color=\"1.0 " + color + " 1.0\"]\n";
                        extract.addStringResult(newExtract.getList());
                    }
                }
            }
        }
        return result;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=Java,basicstyle=\tiny,caption=SDForConvertTree.java]
package DataMiningLogHistoriKIRIWithoutDateAndMinutes;

/**
 *
 * @author Jovan Gunawan
 * Class ini dibuat untuk struktur data yang digunakan untuk mengubah hasil output dari weka menjadi gambar dengan bahasa DOT
 * Class ini khusus untuk skripsi data mining log histori KIRI 
 * 
 * count akan digunakan untuk inisialisasi nomor data --> contoh tanggal1, tanggal 2, .... etc, angka tersebut yang akan ditaruh pada array tersebut
 * array count akan digunakan sebagai berikut --> [0] = tanggal, [1] = bulan, [2] = tahun, [3] = hari, [4] = jam, [5] = menit, [6] = nilai 0, [7] = nilai 1 , [8] = nilai 2
 */
public class SDForConvertTree 
{
    private String[] data;
    private int [] count;
    
    public SDForConvertTree(String [] data)
    {
        this.data = data;
        count = new int[9];
        for(int i = 0; i < 9; i++)
        {
            count[i] = 0;
        }
    }
    
    public void setData(String data, int index)
    {
        this.data[index] = data;
    }
    public String[] getData()
    {
        return data;
    }
    public String getData(int index)
    {
        return this.data[index];
    }
    public void setCount(int count, int index)
    {
        this.count[index] = count;
    }
    public int getCount(int index)
    {
        int temp = this.count[index];
        this.count[index]++;
        return temp;
    }
    public boolean hasNext()
    {
        if(this.data.length > 0)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    
    public void buangArrayPertama()
    {
        String[] temp = new String [data.length-1];
        System.arraycopy(data, 1, temp, 0, data.length-1);
        data = temp;
    }
    public String getDataNumber(String atribut)
    {
        String result = atribut;
        if(atribut.equals("tanggal"))
        {
            result += count[0];
            count[0]++;
        }
        else if(atribut.equals("bulan"))
        {
            result += count[1];
            count[1]++;
        }
        else if(atribut.equals("tahun"))
        {
            result += count[2];
            count[2]++;
        }
        else if(atribut.equals("hari"))
        {
            result += count[3];
            count[3]++;
        }
        else if(atribut.equals("jam"))
        {
            result += count[4];
            count[4]++;
        }
        else if(atribut.equals("menit"))
        {
            result += count[5];
            count[5]++;
        }
        else if(atribut.equals("-1"))
        {
            result += count[6];
            count[6]++;
        }
        else if(atribut.equals("1"))
        {
            result += count[7];
            count[7]++;
        }
        else if(atribut.equals("0"))
        {
            result += count[8];
            count[8]++;
        }
        return result;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=Java,basicstyle=\tiny,caption=SDForExtractData.java]
package DataMiningLogHistoriKIRIWithoutDateAndMinutes;

import java.util.ArrayList;

/**
 *
 * @author Jovan Gunawan
 */
public class SDForExtractData 
{
    private String[] atribut;
    private boolean[] check;
    private int[] batasAtas;
    private int[] batasBawah;
    private int[] maxBatasAtas;
    private int[] minBatasBawah;
    private int kelas;
    private ArrayList<String> list;
    
    public SDForExtractData(String[] atribut, int[] max, int[] min)
    {
        int length = atribut.length;
        this.atribut = new String[length];
        this.maxBatasAtas = new int[length];
        this.minBatasBawah = new int[length];
        this.batasAtas = new int[length];
        this.batasBawah = new int[length];
        this.check = new boolean[length];
        list = new ArrayList<String>();
        
        for(int i = 0; i < length; i++)
        {
            this.atribut[i] = atribut[i];
            this.maxBatasAtas[i] = max[i];
            this.batasAtas[i] = max[i];
            this.minBatasBawah[i] = min[i];
            this.batasBawah[i] = min[i];
            check[i] = false;
        }
    }
    
    public SDForExtractData(SDForExtractData data)
    {
        String[] atribut = data.getAtribut();
        int[] max = data.getMaxBatasAtas();
        int[] min = data.getMinBatasBawah();
        int[] bmax = data.getBatasAtas();
        int[] bmin = data.getBatasBawah();
        boolean[] check = data.getCheck();
        int length = data.getAtribut().length;
        list = data.getList();
        
        this.atribut = new String[length];
        this.maxBatasAtas = new int[length];
        this.minBatasBawah = new int[length];
        this.batasAtas = new int[length];
        this.batasBawah = new int[length];
        this.check = new boolean[length];
        
        for(int i = 0; i < length; i++)
        {
            this.atribut[i] = atribut[i];
            this.maxBatasAtas[i] = max[i];
            this.batasAtas[i] = bmax[i];
            this.minBatasBawah[i] = min[i];
            this.batasBawah[i] = bmin[i];
            this.check[i] = check[i];
        }
    }
    
    public void setKelas(int kelas)
    {
        this.kelas = kelas;
    }
    
    public void setRules(String atribut, String rulesOperation, int value)
    {
        int index = 0;
        for(int i = 0; i < this.atribut.length; i++)
        {
            if(this.atribut[i].equals(atribut))
            {
                index = i;
                break;
            }
        }
        check[index] = true;
        
        if(rulesOperation.equals("<="))
        {
            batasAtas[index] = value;
        }
        else if(rulesOperation.equals("<"))
        {
            batasAtas[index] = value-1;
        }
        else if(rulesOperation.equals(">="))
        {
            batasBawah[index] = value;
        }
        else if(rulesOperation.equals(">"))
        {
            batasBawah[index] = value+1;
        }
        else if(rulesOperation.equals("="))
        {
            batasAtas[index] = value;
            batasBawah[index] = value;
        }
    }
    
    public void extract()
    {
        String[] hari = new String[]{"Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu", "Minggu"};
        boolean in = false;
        String result = "";
        for(int i = 0; i < atribut.length; i++)
        {
            if(check[i])
            {
                if(in)
                {
                    result += " && ";
                }
                if(batasBawah[i] == batasAtas[i])
                {
                    result += atribut[i] + " = " + batasAtas[i];
                }
                else
                {
                    result += atribut[i] + ": " + batasBawah[i] + " - " + batasAtas[i]; 
                }
                in = true;
            }
        }
        
        if(kelas == 1)
        {
            result += " -> Menuju ke Bandung";
        }
        else if(kelas == 0)
        {
            result += " -> Menuju daerah yang sama";
        }
        else
        {
            result += " -> Menjauh dari Bandung";
        }
        list.add(result);
    }
    
    public void addStringResult(ArrayList<String> result)
    {
        list = result;
    }

    public String[] getAtribut() {
        return atribut;
    }

    public boolean[] getCheck() {
        return check;
    }

    public int[] getBatasAtas() {
        return batasAtas;
    }

    public int[] getBatasBawah() {
        return batasBawah;
    }

    public int[] getMaxBatasAtas() {
        return maxBatasAtas;
    }

    public int[] getMinBatasBawah() {
        return minBatasBawah;
    }

    public int getKelas() {
        return kelas;
    }

    public ArrayList<String> getList() {
        return list;
    }
    
}
\end{lstlisting}

\begin{lstlisting}[language=Java,basicstyle=\tiny,caption=CMD.java]
package DataMiningLogHistoriKIRIWithoutDateAndMinutes;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 *
 * @author Jovan Gunawan
 */
public class Cmd 
{
    public static void makeJpgUsingDotCommand()
    {
        try {
            final String dir = System.getProperty("user.dir");
            
            ProcessBuilder builder = new ProcessBuilder(
            "cmd.exe", "/c", "cd graphviz && cd bin && dot \"" + dir + "\\tree.txt\" -o \"" + dir + "\\tree.jpg\" -Tjpg ");
            builder.redirectErrorStream(true);
            Process p = builder.start();
            BufferedReader r = new BufferedReader(new InputStreamReader(p.getInputStream()));
            String line;
            while (true) {
                line = r.readLine();
                if (line == null) 
                { 
                    break; 
                }
                System.out.println(line);
            }
        } catch (IOException e) {
            System.out.println("Error ketika proses CMD");
            System.exit(1);
        }
    }
}
\end{lstlisting}